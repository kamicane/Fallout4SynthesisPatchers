using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.FormKeys.Fallout4;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.WPF.Reflection.Attributes;
using Mutagen.Bethesda.Plugins.Records;
using Noggog;

namespace ModReEvaluator {
	public class Program {
		static Lazy<ProgramSettings> localSettings = null!;
		static IPatcherState<IFallout4Mod, IFallout4ModGetter> localState = null!;
		public static async Task<int> Main (string[] args) {
			return await SynthesisPipeline.Instance
				.AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
				.SetAutogeneratedSettings(
					nickname: "Settings",
					path: "ModReEvaluator_Settings.json",
					out localSettings)
				.SetTypicalOpen(GameRelease.Fallout4, "SYN_ModReEvaluator.esp")
				.Run(args);
		}

		public static string NiceForm (IMajorRecordGetter form) {
			var formatted = $"{form.FormKey.ModKey}|{form.FormKey.ID:X}";
			if (form.EditorID != null) formatted += $" ({form.EditorID})";
			return formatted;
		}

		public static void LogError (string message) {
			Console.WriteLine($"ERROR: {message}");
		}

		public static void LogWarning (string message) {
			if (localSettings.Value.LogLevel <= (ProgramSettings.LogLevelEnum)1) Console.WriteLine($"WARNING: {message}");
		}

		public static void LogInfo (string message) {
			if (localSettings.Value.LogLevel == 0) Console.WriteLine($"INFO: {message}");
		}

		public static (uint, float) RegisterComponent (
			IComponentGetter componentItem,
			uint componentCount,
			List<MiscItemComponent> miscComponentsList,
			List<ConstructibleObjectComponent> cobjComponentsList) {
			var cmpoScrapItem = componentItem.ScrapItem?.TryResolve<IMiscItemGetter>(localState.LinkCache);
			if (cmpoScrapItem == null) {
				LogWarning($"Component has no ScrapItem: {NiceForm(componentItem)}");
				return (0, 0);
			}

			var cmpoScalar = componentItem.ModScrapScalar?.TryResolve<IGlobalGetter>(localState.LinkCache);

			uint scaledComponentCount = componentCount;

			if (cmpoScalar != null) {
				if (cmpoScalar.Equals(Fallout4.Global.ModScrapScalar_None)) {
					scaledComponentCount = 0;
				} else if (cmpoScalar.Equals(Fallout4.Global.ModScrapScalar_SuperCommon)) {
					scaledComponentCount = (uint)Math.Floor(0.75 * scaledComponentCount);
				} else if (cmpoScalar.Equals(Fallout4.Global.ModScrapScalar_Uncommon)) {
					scaledComponentCount = (uint)Math.Floor(0.5 * scaledComponentCount);
				} else if (cmpoScalar.Equals(Fallout4.Global.ModScrapScalar_Rare)) {
					scaledComponentCount = (uint)Math.Floor(0.25 * scaledComponentCount);
				}
			}

			uint cmpoValue = (uint)cmpoScrapItem.Value;
			float cmpoWeight = cmpoScrapItem.Weight;

			if (scaledComponentCount > 0) {
				MiscItemComponent miscItemComponentEntry = new() {
					Component = componentItem.ToLink(),
					Count = scaledComponentCount
				};
				miscComponentsList.Add(miscItemComponentEntry);
			}

			ConstructibleObjectComponent cobjComponentEntry = new() {
				Component = componentItem.ToLink(),
				Count = componentCount
			};
			cobjComponentsList.Add(cobjComponentEntry);

			return (cmpoValue * componentCount, cmpoWeight * componentCount);
		}

		public static bool IsScrapScalarNone (IComponentGetter component) {
			var scalarValue = component.ModScrapScalar?.TryResolve<IGlobalGetter>(localState.LinkCache);
			if (scalarValue != null && scalarValue.Equals(Fallout4.Global.ModScrapScalar_None)) {
				return true;
			}
			return false;
		}

		public static void ProcessCobj (IConstructibleObjectGetter cobjItem) {
			var omodItem = cobjItem.CreatedObject.TryResolve<IAObjectModificationGetter>(localState.LinkCache);
			// nothing to do
			if (omodItem == null || (omodItem is not IWeaponModificationGetter && omodItem is not IArmorModificationGetter)) return;

			var mnams = omodItem.TargetOmodKeywords;

			if (mnams == null) {
				LogWarning($"Mod Association is NULL, Skipping OMOD: {NiceForm(omodItem)}");
				return;
			}

			uint totalValue = 0;
			float totalWeight = 0;

			bool cobjNeedsFix = false;

			ExtendedList<ConstructibleObjectComponent> cobjComponentsList = new();
			ExtendedList<MiscItemComponent> miscComponentsList = new();

			bool shouldRemoveLooseMod = true;

			if (cobjItem.Components?.Count == 0) cobjNeedsFix = true;

			if (cobjItem.Components != null) {
				foreach (var componentEntry in cobjItem.Components) {
					var cKey = componentEntry.Component?.TryResolve(localState.LinkCache);
					var cCount = componentEntry.Count;

					if (cKey == null) {
						LogWarning($"Empty Component. COBJ: {NiceForm(cobjItem)}");
						cobjNeedsFix = true;
						continue;
					}

					if (cCount <= 0) {
						LogWarning($"Zero count. COBJ: {NiceForm(cobjItem)}");
						cobjNeedsFix = true;
						continue;
					}

					if (cKey is IComponentGetter cKeyComponent) {
						if (shouldRemoveLooseMod && !IsScrapScalarNone(cKeyComponent)) shouldRemoveLooseMod = false;

						var valueAndWeight = RegisterComponent(cKeyComponent, cCount, miscComponentsList, cobjComponentsList);
						totalValue += valueAndWeight.Item1;
						totalWeight += valueAndWeight.Item2;

					} else if (cKey is IMiscItemGetter cKeyMisc) {
						// allow only misc items without components.
						// only value and weight will be added.
						// loose mod will be forced on. cannot be added to scraplist.
						cobjNeedsFix = true;

						if (cKeyMisc.Components == null || cKeyMisc.Components.Count == 0) {
							if (shouldRemoveLooseMod) shouldRemoveLooseMod = false;

							LogInfo($"COBJ is using MiscItem as Component. COBJ: {NiceForm(cobjItem)}, MISC: {NiceForm(cKeyMisc)}");

							totalValue += (uint)cKeyMisc.Value;
							totalWeight += cKeyMisc.Weight;

							ConstructibleObjectComponent cobjComponentEntry = new() {
								Component = cKeyMisc.ToLink(),
								Count = cCount
							};
							cobjComponentsList.Add(cobjComponentEntry);

							continue;
						}

						foreach (var miscComponentEntry in cKeyMisc.Components) {
							var miscComponentEntryComponent = miscComponentEntry.Component?.TryResolve<IComponentGetter>(localState.LinkCache);
							if (miscComponentEntryComponent == null) {
								LogWarning($"Invalid Component Entry. MISC: {NiceForm(cKeyMisc)}");
								continue;
							}

							if (shouldRemoveLooseMod && !IsScrapScalarNone(miscComponentEntryComponent)) shouldRemoveLooseMod = false;

							var valueAndWeight = RegisterComponent(miscComponentEntryComponent, miscComponentEntry.Count * cCount, miscComponentsList, cobjComponentsList);
							totalValue += valueAndWeight.Item1;
							totalWeight += valueAndWeight.Item2;
						}

						LogWarning($"Converted scrappable MISC to base components. COBJ: {NiceForm(cobjItem)}, MISC: {NiceForm(cKeyMisc)}");
					} else {
						cobjNeedsFix = true;
						LogWarning($"Removing invalid Component. COBJ: {NiceForm(cobjItem)}, Form: {NiceForm(cKey)}");
					}
				}
			}

			if (cobjNeedsFix) {
				var fixedCobj = localState.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobjItem);
				if (cobjComponentsList.Count > 0) fixedCobj.Components = cobjComponentsList;
				else fixedCobj.Components?.Clear();
			}

			var objectMod = localState.PatchMod.ObjectModifications.GetOrAddAsOverride(omodItem);

			var looseMiscItem = objectMod.LooseMod.TryResolve<IMiscItemGetter>(localState.LinkCache);

			if (looseMiscItem != null) {
				if (!shouldRemoveLooseMod) {
					var fixedLooseMod = localState.PatchMod.MiscItems.GetOrAddAsOverride(looseMiscItem);
					if (localSettings.Value.MakeLooseModsScrappable && miscComponentsList.Count > 0) fixedLooseMod.Components = miscComponentsList;
					else fixedLooseMod.Components?.Clear();

					fixedLooseMod.Value = (int)totalValue;
					fixedLooseMod.Weight = totalWeight;
				} else {
					LogInfo($"Removing loose mod. COBJ: {NiceForm(cobjItem)}, OMOD: {NiceForm(omodItem)}");
					objectMod.LooseMod.Clear();

					if (looseMiscItem.Value != 0 || looseMiscItem.Weight != 0 || looseMiscItem.Components != null) {
						var fixedLooseMod = localState.PatchMod.MiscItems.GetOrAddAsOverride(looseMiscItem);
						fixedLooseMod.Value = 0;
						fixedLooseMod.Weight = 0;
						fixedLooseMod.Components?.Clear();
						LogInfo($"Zeroed value, weight and components. MISC: {NiceForm(looseMiscItem)}");
					}
				}
			} else if (miscComponentsList.Count > 0) {
				LogWarning($"No loose mod on COBJ with components. COBJ: {NiceForm(cobjItem)}, OMOD: {NiceForm(omodItem)}");
			}

			if (objectMod is WeaponModification weaponMod) {
				for (int i = weaponMod.Properties.Count - 1; i >= 0; i--) {
					var prop = weaponMod.Properties[i];

					if (prop.Property == Weapon.Property.Value || prop.Property == Weapon.Property.Weight) {
						weaponMod.Properties.RemoveAt(i);
					}
				}

				if (totalValue > 0) {
					ObjectModIntProperty<Weapon.Property> newProp = new() {
						FunctionType = ObjectModProperty.FloatFunctionType.Add,
						Property = Weapon.Property.Value,
						Value = totalValue
					};
					weaponMod.Properties.Add(newProp);
				}

				if (totalWeight > 0) {
					ObjectModFloatProperty<Weapon.Property> newProp = new() {
						FunctionType = ObjectModProperty.FloatFunctionType.Add,
						Property = Weapon.Property.Weight,
						Value = totalWeight
					};
					weaponMod.Properties.Add(newProp);
				}
			} else if (objectMod is ArmorModification armorMod) { //eww
				for (int i = armorMod.Properties.Count - 1; i >= 0; i--) {
					var prop = armorMod.Properties[i];

					if (prop.Property == Armor.Property.Value || prop.Property == Armor.Property.Weight) {
						armorMod.Properties.RemoveAt(i);
					}
				}

				if (totalValue > 0) {
					ObjectModIntProperty<Armor.Property> newProp = new() {
						FunctionType = ObjectModProperty.FloatFunctionType.Add,
						Property = Armor.Property.Value,
						Value = totalValue
					};
					armorMod.Properties.Add(newProp);
				}

				if (totalWeight > 0) {
					ObjectModFloatProperty<Armor.Property> newProp = new() {
						FunctionType = ObjectModProperty.FloatFunctionType.Add,
						Property = Armor.Property.Weight,
						Value = totalWeight
					};
					armorMod.Properties.Add(newProp);
				}
			}
		}

		public static void RunPatch (IPatcherState<IFallout4Mod, IFallout4ModGetter> state) {
			// Add NotJunkJetAmmo keyword to component scrap if missing
			localState = state;

			var componentItems = localState.LoadOrder.PriorityOrder.Component().WinningOverrides();

			foreach (var componentItem in componentItems) {
				var miscItem = componentItem.ScrapItem?.TryResolve<IMiscItemGetter>(localState.LinkCache);
				if (miscItem == null) continue;

				if (!miscItem.HasKeyword(Fallout4.Keyword.NotJunkJetAmmo)) {
					var miscItemOverride = localState.PatchMod.MiscItems.GetOrAddAsOverride(miscItem);
					miscItemOverride.Keywords ??= new();
					miscItemOverride.Keywords.Add(Fallout4.Keyword.NotJunkJetAmmo);
				}
			}

			// Sanity Pass
			// minimum weight and minimum value checks

			var miscItems = localState.LoadOrder.PriorityOrder.MiscItem().WinningOverrides();

			foreach (var miscItem in miscItems) {
				if (miscItem.Components == null || miscItem.Components.Count == 0) continue;

				ExtendedList<MiscItemComponent> miscComponentsList = new();
				bool miscNeedsFix = false;

				int minValue = 0;
				float minWeight = 0;

				foreach (var componentEntry in miscItem.Components) {
					var component = componentEntry.Component?.TryResolve<IComponentGetter>(localState.LinkCache);
					if (component == null) {
						LogWarning($"Invalid Component. MISC: {NiceForm(miscItem)})");
						miscNeedsFix = true;
						continue;
					}
					var scrapItem = component.ScrapItem?.TryResolve<IMiscItemGetter>(localState.LinkCache);

					if (scrapItem == null) {
						LogWarning($"Component with no ScrapItem. MISC: {NiceForm(miscItem)}");
						miscNeedsFix = true;
						continue;
					}

					var cCount = componentEntry.Count;

					MiscItemComponent miscItemComponentEntry = new() {
						Component = component.ToLink(),
						Count = cCount
					};
					miscComponentsList.Add(miscItemComponentEntry);

					minValue += (int)(scrapItem.Value * cCount);
					minWeight += scrapItem.Weight * cCount;
				}

				int miscValue = miscItem.Value;
				float miscWeight = miscItem.Weight;

				if (miscItem.Value < minValue) {
					Console.ForegroundColor = ConsoleColor.Yellow;
					LogInfo($"Recalculated value. MISC: {NiceForm(miscItem)}");
					miscNeedsFix = true;
					miscValue = minValue;
				}

				bool isShipment = false;
				if (miscItem.EditorID != null && miscItem.EditorID.StartsWith("shipment_")) isShipment = true;

				if (isShipment && miscItem.Weight != 0) {
					miscNeedsFix = true;
					miscWeight = 0;
				}

				if (!isShipment && miscItem.Weight < minWeight) {
					LogInfo($"Recalculated weight. MISC: {NiceForm(miscItem)}");
					miscNeedsFix = true;
					miscWeight = minWeight;
				}

				if (miscNeedsFix) {
					var fixedMisc = localState.PatchMod.MiscItems.GetOrAddAsOverride(miscItem);
					fixedMisc.Components = miscComponentsList;
					fixedMisc.Value = miscValue;
					fixedMisc.Weight = miscWeight;
				}
			}

			// Process COBJs

			var cobjItems = localState.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides();
			foreach (var cobjItem in cobjItems) {
				if (localSettings.Value.COBJExcludeList.Contains(cobjItem)) continue;
				ProcessCobj(cobjItem);
			}
		}
	}

	public class ProgramSettings {
		[MaintainOrder]
		[SettingName("Make Loose Mods Scrappable (Warning: read docs)")]
		public bool MakeLooseModsScrappable = false;
		// [MaintainOrder]
		// [SettingName("Remove All Loose Mods (Starfield Style)")]
		// public bool RemoveAllLooseMods = false;

		// [MaintainOrder]
		// [SettingName("Scrap Scalar Values")]
		// public Dictionary<string, float> ScrapScalarValues = new()
		// {
		//	{ "ModScrapScalar_Full", 1.0f }
		//	{ "ModScrapScalar_SuperCommon", 0.75f },
		//	{ "ModScrapScalar_Uncommon", 0.5f },
		//	{ "ModScrapScalar_Rare", 0.25f }
		//	{ "ModScrapScalar_None", 0.0f },
		// };

		[MaintainOrder]
		[SettingName("Log Level")]
		public LogLevelEnum LogLevel = LogLevelEnum.Warning;

		[MaintainOrder]
		[SettingName("Excluded Recipes")]
		public List<IFormLinkGetter<IConstructibleObjectGetter>> COBJExcludeList = new() {

		};

		public enum LogLevelEnum {
			Info,
			Warning,
			Error
		}
	}
}
